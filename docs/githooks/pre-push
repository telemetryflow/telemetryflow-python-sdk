#!/bin/bash
# ==============================================================================
# TelemetryFlow SDK (Python) - Pre-push Hook
# ==============================================================================
# Runs comprehensive checks before allowing a push
# - Full lint check
# - Type checking
# - Full test suite with coverage
# - Build verification
# - API compatibility check
# - Branch protection rules
# ==============================================================================

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
success() { echo -e "${GREEN}âœ… $1${NC}"; }
warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
error() { echo -e "${RED}âŒ $1${NC}"; }

# Get remote and branch info
REMOTE="$1"
URL="$2"

# Read stdin for refs being pushed
while read LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
    if [ "$LOCAL_SHA" = "0000000000000000000000000000000000000000" ]; then
        # Deleting a branch, skip checks
        continue
    fi

    BRANCH=$(echo "$LOCAL_REF" | sed 's|refs/heads/||')

    echo ""
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘      TelemetryFlow SDK (Python) - Pre-push Checks            â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${CYAN}Remote:${NC} $REMOTE ($URL)"
    echo -e "${CYAN}Branch:${NC} $BRANCH"
    echo ""

    # ==========================================================================
    # Check 1: Protected branch warnings
    # ==========================================================================
    PROTECTED_BRANCHES="main master develop"

    for protected in $PROTECTED_BRANCHES; do
        if [ "$BRANCH" = "$protected" ]; then
            warning "You are pushing to protected branch: $BRANCH"
            echo ""

            # Check if pushing directly (not via PR)
            if [ "$REMOTE_SHA" != "0000000000000000000000000000000000000000" ]; then
                # Get the commits being pushed
                COMMITS=$(git log --oneline "$REMOTE_SHA..$LOCAL_SHA" 2>/dev/null || echo "")
                COMMIT_COUNT=$(echo "$COMMITS" | grep -c "." || echo "0")

                if [ "$COMMIT_COUNT" -gt 0 ]; then
                    info "Commits being pushed:"
                    echo "$COMMITS" | while read -r commit; do
                        echo "  - $commit"
                    done
                    echo ""
                fi
            fi

            read -p "Are you sure you want to push to $BRANCH? (y/N) " -n 1 -r </dev/tty
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error "Push to $BRANCH cancelled"
                exit 1
            fi
            break
        fi
    done

    # ==========================================================================
    # Check 2: Black formatting
    # ==========================================================================
    if command -v black &> /dev/null; then
        info "Running Black formatting check..."

        if black --check . 2>/dev/null; then
            success "Black formatting passed"
        else
            error "Black formatting failed. Please run 'black .' before pushing."
            exit 1
        fi
        echo ""
    else
        warning "Black not installed, skipping"
        echo ""
    fi

    # ==========================================================================
    # Check 3: isort import sorting
    # ==========================================================================
    if command -v isort &> /dev/null; then
        info "Running isort check..."

        if isort --check-only . 2>/dev/null; then
            success "isort passed"
        else
            error "isort failed. Please run 'isort .' before pushing."
            exit 1
        fi
        echo ""
    else
        warning "isort not installed, skipping"
        echo ""
    fi

    # ==========================================================================
    # Check 4: Ruff linting (full)
    # ==========================================================================
    if command -v ruff &> /dev/null; then
        info "Running full Ruff linting..."

        if ruff check . 2>/dev/null; then
            success "Ruff linting passed"
        else
            error "Ruff linting failed. Please fix all issues before pushing."
            exit 1
        fi
        echo ""
    else
        warning "Ruff not installed, skipping"
        echo ""
    fi

    # ==========================================================================
    # Check 5: MyPy type checking
    # ==========================================================================
    if command -v mypy &> /dev/null; then
        info "Running MyPy type checking..."

        # Run mypy on src/ directory only (tests/examples excluded in pyproject.toml)
        if [ -d "src" ]; then
            if mypy src/ 2>/dev/null; then
                success "MyPy type checking passed"
            else
                error "MyPy type checking failed. Please fix all type errors before pushing."
                exit 1
            fi
        else
            info "No src/ directory found, skipping type checking"
        fi
        echo ""
    else
        warning "MyPy not installed, skipping"
        echo ""
    fi

    # ==========================================================================
    # Check 6: Full test suite with 95% coverage (including tests/ directory)
    # ==========================================================================
    if command -v pytest &> /dev/null; then
        info "Running full test suite with coverage..."

        # Coverage threshold (set to 80% - adjust based on project requirements)
        COVERAGE_THRESHOLD=80

        # Run all tests including tests/ directory
        TEST_FAILED=false

        # Run tests from tests/ directory if it exists
        if [ -d "tests" ]; then
            # Run unit tests if directory exists and has Python test files
            if [ -d "tests/unit" ]; then
                if find tests/unit -name "test_*.py" -o -name "*_test.py" 2>/dev/null | grep -q .; then
                    info "Running unit tests from tests/unit/..."
                    if ! pytest tests/unit --tb=short 2>/dev/null; then
                        TEST_FAILED=true
                    fi
                else
                    info "No test files in tests/unit/, skipping"
                fi
            fi

            # Run integration tests (optional, can be skipped with env var)
            if [ -d "tests/integration" ] && [ "$SKIP_INTEGRATION_TESTS" != "true" ]; then
                if find tests/integration -name "test_*.py" -o -name "*_test.py" 2>/dev/null | grep -q .; then
                    info "Running integration tests from tests/integration/..."
                    if ! pytest tests/integration --tb=short 2>/dev/null; then
                        warning "Integration tests failed (set SKIP_INTEGRATION_TESTS=true to skip)"
                        TEST_FAILED=true
                    fi
                else
                    info "No test files in tests/integration/, skipping"
                fi
            fi

            # Run e2e tests (optional, can be skipped with env var)
            if [ -d "tests/e2e" ] && [ "$SKIP_E2E_TESTS" != "true" ]; then
                if find tests/e2e -name "test_*.py" -o -name "*_test.py" 2>/dev/null | grep -q .; then
                    info "Running e2e tests from tests/e2e/..."
                    if ! pytest tests/e2e --tb=short 2>/dev/null; then
                        warning "E2E tests failed (set SKIP_E2E_TESTS=true to skip)"
                        TEST_FAILED=true
                    fi
                else
                    info "No test files in tests/e2e/, skipping"
                fi
            fi
        fi

        # Run main package tests with coverage
        info "Running main package tests with coverage..."
        if ! pytest --cov=. --cov-report=term-missing --cov-fail-under=$COVERAGE_THRESHOLD 2>/dev/null; then
            TEST_FAILED=true
        fi

        if [ "$TEST_FAILED" = true ]; then
            error "Tests failed or coverage below ${COVERAGE_THRESHOLD}%. Please fix before pushing."
            exit 1
        fi

        success "All tests passed with coverage (>= ${COVERAGE_THRESHOLD}%)"
        echo ""
    else
        warning "pytest not installed, skipping tests"
        echo ""
    fi

    # ==========================================================================
    # Check 7: Build verification
    # ==========================================================================
    info "Verifying package build..."

    # Check if pyproject.toml or setup.py exists
    if [ -f "pyproject.toml" ]; then
        if command -v python &> /dev/null; then
            # Check if build module and setuptools are available
            if python -c "import build, setuptools" 2>/dev/null; then
                if python -m build --no-isolation 2>/dev/null; then
                    success "Package build successful"
                else
                    warning "Build failed but continuing (may need build dependencies)"
                fi
            else
                # Fallback: verify pyproject.toml is valid by checking package can be imported
                if python -c "import tomllib; tomllib.load(open('pyproject.toml', 'rb'))" 2>/dev/null || \
                   python -c "import toml; toml.load('pyproject.toml')" 2>/dev/null; then
                    success "Package configuration valid (pyproject.toml syntax OK)"
                else
                    warning "Build verification skipped (build/setuptools not installed)"
                fi
            fi
        fi
    elif [ -f "setup.py" ]; then
        if python setup.py --version 2>/dev/null; then
            success "Package configuration valid"
        else
            error "Package configuration invalid. Please fix before pushing."
            exit 1
        fi
    else
        info "No package configuration found, skipping build verification"
    fi
    echo ""

    # ==========================================================================
    # Check 8: Check examples run
    # ==========================================================================
    if [ -d "examples" ]; then
        info "Verifying examples syntax..."

        EXAMPLE_ERRORS=""
        for example in examples/*.py; do
            if [ -f "$example" ]; then
                if ! python -m py_compile "$example" 2>/dev/null; then
                    EXAMPLE_ERRORS="$EXAMPLE_ERRORS\n  - $example"
                fi
            fi
        done

        if [ -n "$EXAMPLE_ERRORS" ]; then
            error "Examples have syntax errors:$EXAMPLE_ERRORS"
            exit 1
        else
            success "Examples syntax valid"
        fi
        echo ""
    fi

    # ==========================================================================
    # Check 9: Check for WIP commits
    # ==========================================================================
    if [ "$REMOTE_SHA" != "0000000000000000000000000000000000000000" ]; then
        WIP_COMMITS=$(git log --oneline "$REMOTE_SHA..$LOCAL_SHA" | grep -iE "(WIP|FIXME|TODO|XXX|HACK):" || true)

        if [ -n "$WIP_COMMITS" ]; then
            warning "Found work-in-progress commits:"
            echo "$WIP_COMMITS" | while read -r commit; do
                echo "  - $commit"
            done
            echo ""
            read -p "Continue pushing with WIP commits? (y/N) " -n 1 -r </dev/tty
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                error "Push cancelled due to WIP commits"
                exit 1
            fi
        fi
    fi

    # ==========================================================================
    # Check 10: Large file detection
    # ==========================================================================
    info "Checking for large files..."

    MAX_FILE_SIZE=5242880  # 5MB in bytes
    LARGE_FILES=""

    if [ "$REMOTE_SHA" = "0000000000000000000000000000000000000000" ]; then
        # New branch, check all files
        FILES=$(git ls-tree -r --name-only "$LOCAL_SHA")
    else
        # Existing branch, check changed files
        FILES=$(git diff --name-only "$REMOTE_SHA..$LOCAL_SHA")
    fi

    for file in $FILES; do
        if [ -f "$file" ]; then
            FILE_SIZE=$(wc -c < "$file" 2>/dev/null || echo "0")
            if [ "$FILE_SIZE" -gt "$MAX_FILE_SIZE" ]; then
                LARGE_FILES="$LARGE_FILES\n  - $file ($(numfmt --to=iec-i --suffix=B $FILE_SIZE 2>/dev/null || echo "${FILE_SIZE} bytes"))"
            fi
        fi
    done

    if [ -n "$LARGE_FILES" ]; then
        warning "Large files detected (>5MB):$LARGE_FILES"
        echo ""
        read -p "Continue pushing with large files? (y/N) " -n 1 -r </dev/tty
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            error "Push cancelled due to large files"
            exit 1
        fi
    else
        success "No large files detected"
    fi
    echo ""

    # ==========================================================================
    # Summary
    # ==========================================================================
    echo ""
    echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${GREEN}â•‘               All pre-push checks passed! ðŸš€                 â•‘${NC}"
    echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${CYAN}Pushing to:${NC} $REMOTE/$BRANCH"
    echo ""

done

exit 0
